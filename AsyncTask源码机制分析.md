1. 对handler异步消息机制的一个封装。用于子线程处理耗时任务，主线程进行结果回调。
2. 从android1.5版本开始引入，最多只有5个线程同时执行，也就是添加进来的任务，多余5个的需要等前面的处理完才能继续执行后面的任务。任务数量最多只能保存128个，超过128个会崩溃。从android3.0以后，默认处理方式变成序列化的处理，处理完一个任务后再轮循下一条任务进行处理，默认处理方式没有任务数量限制。
3. 几个重要方法
    1. doInBackground：处理耗时任务，运行与子线程。
    2. onProgressUpdate：当前的任务处理进度，运行于主线程。
    3. onPostExecute：任务处理结果回调，运行于主线程。
4. 构造方法：
    1. 为了实现结果回调到主线程，构造过程会创建绑定与主线程的handler对象来处理回调结果。由handler异步通信机制可知，要在主线程回调结果，handler必须在主线程创建。
    2. 创建WorkerRunnable对象，用于执行doInBackground()方法处理耗时操作。
    3. 创建FutureTask对象，对任务进行处理和相关回调方法调度。
5. 事件处理过程
    1. 使用默认序列线程池SERIAL_EXECUTOR执行任务：同一时刻只能有一条任务被执行，任务执行完成后，轮循任务队列取出下一条任务。无最大任务数限制。
    2. 使用executeOnExecutor方法传入自定义线程池执行任务：任务执行逻辑根据自己定义，普通线程池将会有最大任务数和同时执行任务数的限制。
    3. 根据以上不同策略，使用不同的线程池执行构造方法创建的FutureTask对象将事件转入子线程，FutureTask执行run方法将调用WorkerRunnable的call方法进行处理，call方法里面有会调用doInBackground方法，此时处理线程进入子线程，实现线程切换，对耗时任务进行处理。
    4. WorkerRunnable事件处理被try finally块包裹，最终调用postResult，将处理结果创建message对象，使用handler发送到主线程实现线程切换，UI回调。
    5. 处理过程中调用publishProgress方法将当前处理进度通过handler发送到主线程达到进度回调的目的。


