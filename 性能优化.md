#### UI优化
1. 检测方法
    1. 耗时方法检测:通过Debug.startMethodTracing(“test”)开始跟踪，通过Debug.stopMethodTracing()停止追踪，生成test.trace文件，然后使用android studio的trace view工具打开trace文件查看各方法耗时信息。
    2. 使用HierarchyViewer分析UI性能：查看布局嵌套情况，减少嵌套从而减少过多的绘制。
    3. 我们对于UI性能的优化还可以通过开发者选项中的GPU过度绘制工具来进行分析。在设置->开发者选项->调试GPU过度绘制。查看过度绘制的控件，修改自定义控件绘制逻辑。

2. 优化方法
    1. 布局优化；尽量使用include、merge、ViewStub标签，尽量不存在冗余嵌套及过于复杂布局（譬如10层就会直接异常），尽量使用GONE替换INVISIBLE，使用weight后尽量将width和heigh设置为0dp减少运算，Item存在非常复杂的嵌套时考虑使用自定义Item View来取代，减少measure与layout次数等。
    2. 列表及Adapter优化；尽量复用getView方法中的相关View，不重复获取实例导致卡顿，列表尽量在滑动过程中不进行UI元素刷新等。viewholder优化的是findviewbyid的过程，view的缓存则是listview自身缓存池实现
    3. 背景和图片等内存分配优化；尽量减少不必要的背景设置，图片尽量压缩处理显示，尽量避免频繁内存抖动等问题出现。
    4. 自定义View等绘图与布局优化；尽量避免在draw、measure、layout中做过于耗时及耗内存操作，尤其是draw方法中，尽量减少draw、measure、layout等执行次数。
    5. 避免ANR，不要在UI线程中做耗时操作，遵守ANR规避守则，譬如多次数据库操作等。

#### 内存优化
1. 内存泄露：本来应该被回收的对象却被别的对象错误的引用导致无法被回收，导致卡顿，OOM崩溃。导致原因：一个对象持有了超过自己生命周期以外的对象强引用导致该对象无法被正常垃圾回收。
2. 内存泄露分析：leakcanary第三方库检测。
3. 内存泄露规避
    * Context使用不当造成内存泄露；不要对一个Activity Context保持长生命周期的引用（譬如上面概念部分给出的示例）。尽量在一切可以使用应用ApplicationContext代替Context的地方进行替换（原理我前面有一篇关于Context的文章有解释）。
    * 非静态内部类的静态实例容易造成内存泄漏；即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。
    * 对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。
    * 创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。
    * bitmap使用完及时回收
    * 打开外部二进制文件。
4. OOM：无法申请到需要的内存，消耗内存过多。
    * 应用代码存在内存泄露，长时间积累无法释放导致OOM；
    * 应用的某些逻辑操作疯狂的消耗掉大量内存（譬如加载一张不经过处理的超大超高清图片等）导致超过阈值OOM；
5. ArrayMap内部使用两个数组进行数据存储，一个记录Key的Hash值，一个记录Value值，它和SparseArray类似，也会在查找时对Key采用二分法。
6. 图片优化：android3.0以前，bitmap像素数据内存分配在native堆里面，其他部分在dalvik虚拟机的内存，3.0以后，全部都在java堆里面。
    * lru缓存bitmap，防止重复加载
    * bitmap缩略图：加载大小参数，根据当前显示控件尺寸计算合适大小然后再设置上去加载。
    * 滑动过程不要加载，列表停止之后才开始加载。
    * 设置bitmap的显示质量参数RGB565
    * 不用的bitmap及时回收