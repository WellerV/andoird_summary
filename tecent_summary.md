1. java对象的引用保存在方法栈中，对象实例保存在栈中，对象保存在堆中。float对象保存在堆中。数组存放在堆里，数组元素存放的是对象的引用，存放在栈中。
2. draw绘制背景，过程中会调用onDraw方法，自定义view可以通过onDraw实现绘制效果。然后调用dispatchDraw进行绘制事件分发
3. volatile：主存，java堆中对象实例部分。主存不同于java虚拟机的内存模型 是所有线程共享的，硬要对比，可以类比成堆中的实例部分.
4. 老年代：标记清除和标记整理。年轻代：复制。因为年轻带大部分会被回收，可用内存大，有内存担保
5. 字符串常量值相加，编译器优化，可看做是两个常量值相加之后的一个值，但是创建了三个对象。如果常量值跟字符串引用相加，单独开辟内存，创建两个对象。string赋值常量值，创建一个常量。
6. 电量调优，io优化
7. 音视频编解码，socket实现预加载
8. 数组是引用型变量，内存分配在堆中。数组元素存放的是对象的引用，数组的引用和数组元素的引用存放在栈中。float和double存放在堆中。long和double的操作属于非原子操作。
9. 进程fork目的：获取zygote进程的一份数据拷贝，主要是进程数据空间，堆，栈等资源的副本，从而完成新进程的快速创建。
10. launcher启动进程的过程：用户在桌面点击图标，launcher通过ActivityManagerNative.getDefault()拿到ActivityManagerService远程进程在当前应用进程的binder代理对象，通过这个binder代理调用系统调用将intent数据发送到binderDriver，binderDriver创建一块虚拟共享内存，并使用内存映射同时映射到到用户空间和BinderDriver内核空间，当binder代理将数据发送到BinderDriver的时候，由于内存映射，用户空间也就是远程进程ActivityManagerService的用户空间。ActivityManagerService拿到数据之后对数据进行解析，并检测相应待启动的Activity所在进程有没有启动，没有的话，通过zygote进程fork一个子进程获取zygote进程的数据拷贝，堆，栈等数据。然后ActivityManagerService通过IApplicationThreadProxy，待启动进程的binder对象在ActivityManagerService的代理对象，再次使用进程间通信的方法将启动activity数据发送到activity进程，activity进程ApplicationThread获取到数据之后，使用Handler切换到ActivityThread主线程进行activity的实际创建操作(利用反射创建activity类),并将binder对象和activity绑定起来，ActivityManagerService通过binder识别activity进行生命周期管理。
11. system trace
11. surface view
11. surface
11. ui thread 和 renderThread
11. recycler view 和 listView的对比。
leack canery没有检查到内存泄漏，怎么样优化。  mat优化。
decor view
字符串切分：inputStream一行一行的读取字符，转化成string之后内存可能不够用,也可能造成很多临时变量造成内存抖动。
