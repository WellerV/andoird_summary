#### 内存模型
1. 线程私有数据区:只有当前线程可以访问的数据
    * 程序计数器：记录正在执行的虚拟机字节码指令的地址，宏观表现为当前执行的代码行
    * 虚拟机栈：保存java方法相关数据 -> 局部变量表，操作数栈，动态链接，方法出口。方法一旦执行，虚拟会为方法创建一个栈帧保存相关数据然后进栈，方法执行完，这个栈帧就会出栈，当栈深度超过最大值会报StackOverFlow异常，通常发生在递归和循环调用，方法没有出栈又进栈导致栈深度过深。无法申请到更多内存即内存不够时会报OOM。
    * 本地方法栈：保存Native方法相关数据，跟虚拟机展类似。
2. 线程共享数据区：同一个进程内都可以访问的数据
    * 堆：保存对象实例，垃圾收集器管理的主要区域，内存活跃度高。
    * 方法区：存放已被虚拟机加载的类信息，常量，静态变量等数据。

#### 垃圾收集
1. 根据内存模型可以知道，程序计数器，虚拟机栈和本地方法栈都是线程私有的，只存在于线程的生命周期内。线程结束会跟随生命周期而消失，所以这部分的内存不需要回收。线程回收针对的是java堆和方法区。
2. 垃圾回收时机
    * 引用计数：给对象添加一个引用计数器，每引用一次加1，失效减1，当为0时，GC扫描回收将会回收这个引用占用的内存。
    * 可达性：以虚拟机栈，本地方法栈，方法区中常量和静态属性引用的对象作为起点搜索，不处于调用链中的对象为不可达，符合回收条件。
    * 引用类型
        1. 强引用：必须手动释放，否则无法被回收。
        1. 软引用：内存不够时，将会被回收释放。
        1. 弱引用：到下一次GC扫描的时候，就会回收。
        1. 虚引用：没有任何保证，随时都可能会被回收，唯一用途是在回收时收到通知。

#### 垃圾收集算法
1. 标记 - 清除算法：将需要回收的对象进行标记，然后清除。缺点是标记和清除过程效率都不高，而且会会产生大量碎片。
2. 复制算法：将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。缺点是没有充分利用内存，都只使用了一半。
3. 标记 - 整理算法：将需要回收的对象进行标记，然后将剩下的存活对象往一端移动，清理掉除了这一端以外的所有内存。
4. 分代收集算法：将java堆分为新生代和老年代，不同区域采用不同垃圾收集算法
    * 新生代：复制算法
    * 老年代：标记 - 清理 或者 标记 - 整理 算法。

#### 类加载机制
1. 生命周期:加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载
2. 类的初始化时机，有且仅有以下五种情况，类将会得到加载
    *  new、getstatic、putstatic、invokestatic 。创建对象，获取和设置静态变量，调用静态方法。
    *  通过反射调用一个类的时候。
    *  一个类初始化的时候，如果父类没有初始化过，父类将会执行初始化。
    *  程序入口类，定义main()方法的类。

#### 类加载过程
1. 加载：类的加载是类加载的一个过程，主要完成以下三件事：
    * 通过一个类的全限定名来获取定义此类的二进制字节流。
    * 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。
    * 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。
2. 验证：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证内容：文件格式验证，元数据验证（对字节码描述的信息进行语义分析），字节码验证（通过数据流和控制流分析，确保程序语义是合法、符合逻辑的，将对类的方法体进行校验分析），符号引用验证
3. 准备：为类变量分配内存并设置初始值。
3. 初始化：静态语句块只能访问定义在它之前的类变量，定义在之后的变量只能在静态语句块里面进行赋值操作。当前类初始化之前先执行父类的初始化操作，所以先执行父类静态语句，再执行自己，然后执行父类实例变量。这个过程是加锁同步的。

#### 双亲委派模型
1. 工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是把这个请求委派给父类加载器，每一个层次的加载器都是如此，依次递归，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成此加载请求（它搜索范围中没有找到所需类）时，子加载器才会尝试自己加载。
2.