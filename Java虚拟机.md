#### 内存模型
1. 线程私有数据区:只有当前线程可以访问的数据
    * 程序计数器：记录正在执行的虚拟机字节码指令的地址，宏观表现为当前执行的代码行
    * 虚拟机栈：保存java方法相关数据 -> 局部变量表，操作数栈，动态链接，方法出口。方法一旦执行，虚拟会为方法创建一个栈帧保存相关数据然后进栈，方法执行完，这个栈帧就会出栈，当栈深度超过最大值会报StackOverFlow异常，通常发生在递归和循环调用，方法没有出栈又进栈导致栈深度过深。无法申请到更多内存即内存不够时会报OOM。
    * 本地方法栈：保存Native方法相关数据，跟虚拟机展类似。
2. 线程共享数据区：同一个进程内都可以访问的数据
    * 堆：保存对象实例，垃圾收集器管理的主要区域，内存活跃度高。
    * 方法区：存放已被虚拟机加载的类信息，常量，静态变量等数据。

#### 变量内存分配
1. 变量本身就是一个值，引用变量存放的是对象的地址，所以不同的对象引用变量是不相等的。基本型的变量是自动变量，并不是保存的数据的地址，而是直接保存的值，所以只要基本型数据的值相等，不管基本型数据在堆还是栈，变量值都是相等的。
2. 非静态成员(包括引用型和基本型)变量的引用(本身也是一个值，等于对象的地址)和对象实例都保存在堆中。
3. 基本数据类型：boolean，byte，char，short，int，float，double，long。基本型变量是自动变量，没有引用的存在，存放的本身就是基本型数据的值。double和long的写入和读取是非原子操作的。float和double的包装类没有提供缓存，都是new出来的对象，保存在堆中。其他包装类有-128-127的缓存。
4. 变量内存分配取决于声明他们的地方，声明为成员变量的引用变量保存在堆里，对成员变量的操作都会发生在堆里面。
5. 数组是一组连续的内存地址，是一个对象，属于引用型数据，数组引用存放的是这组连续地址的首地址。数组保存在堆中。数组保存在堆中，实例化之后可以直接方法数组中各元素，所以子元素也保存在堆中。所以数组是保存在堆中的对象。
6. volatile:保存在主存中，对数据的操作将立刻刷新到主存中，对数据的读取从主存中读取，保证操作对其他线程的可见性。主存是所有线程共享的内存。
7. 主存：每一个线程都拥有自己的工作内存，而所有这些线程共享一块内存---称之为主存。相对于线程工作内存而言的，与jvm逻辑分区有着不同的概念。
3. 常量，静态变量：保存于方法区，线程共享区域。
3. 常量池：虚拟机为每个被装载的类型维护一个常量池。保存在方法区，线程间共享区域。

#### 垃圾收集
1. 根据内存模型可以知道，程序计数器，虚拟机栈和本地方法栈都是线程私有的，只存在于线程的生命周期内。线程结束会跟随生命周期而消失，所以这部分的内存不需要回收。线程回收针对的是java堆和方法区。
2. 垃圾回收时机
    * 引用计数：给对象添加一个引用计数器，每引用一次加1，失效减1，当为0时，GC扫描回收将会回收这个引用占用的内存。
    * 可达性：以虚拟机栈，本地方法栈，方法区中常量和静态属性引用的对象作为起点搜索，不处于调用链中的对象为不可达，符合回收条件。
    * 引用类型
        1. 强引用：必须手动释放，否则无法被回收。
        1. 软引用：内存不够时，将会被回收释放。
        1. 弱引用：到下一次GC扫描的时候，就会回收。
        1. 虚引用：没有任何保证，随时都可能会被回收，唯一用途是在回收时收到通知。

#### 垃圾收集算法
1. 标记 - 清除算法：将需要回收的对象进行标记，然后清除。缺点是标记和清除过程效率都不高，而且会会产生大量碎片。
2. 复制算法：将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。缺点是没有充分利用内存，都只使用了一半。
3. 标记 - 整理算法：将需要回收的对象进行标记，然后将剩下的存活对象往一端移动，清理掉除了这一端以外的所有内存。
4. 分代收集算法：将java堆分为新生代和老年代，不同区域采用不同垃圾收集算法
    * 新生代：复制算法
    * 老年代：标记 - 清理 或者 标记 - 整理 算法。

#### 类加载机制
1. 生命周期:加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载
2. 类的初始化时机，有且仅有以下五种情况，类将会得到加载
    *  new、getstatic、putstatic、invokestatic 。创建对象，获取和设置静态变量，调用静态方法。
    *  通过反射调用一个类的时候。
    *  一个类初始化的时候，如果父类没有初始化过，父类将会执行初始化。
    *  程序入口类，定义main()方法的类。

#### 类加载过程
1. 加载：类的加载是类加载的一个过程，主要完成以下三件事：
    * 通过一个类的全限定名来获取定义此类的二进制字节流。
    * 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。
    * 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。
2. 验证：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证内容：文件格式验证，元数据验证（对字节码描述的信息进行语义分析），字节码验证（通过数据流和控制流分析，确保程序语义是合法、符合逻辑的，将对类的方法体进行校验分析），符号引用验证
3. 准备：为类变量分配内存并设置初始值。
3. 初始化：静态语句块只能访问定义在它之前的类变量，定义在之后的变量只能在静态语句块里面进行赋值操作。当前类初始化之前先执行父类的初始化操作，所以先执行父类静态语句，再执行自己，然后执行父类实例变量。这个过程是加锁同步的。

#### 双亲委派模型
1. 工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是把这个请求委派给父类加载器，每一个层次的加载器都是如此，依次递归，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成此加载请求（它搜索范围中没有找到所需类）时，子加载器才会尝试自己加载。
2.

#### 垃圾收集
1. 判断一个对象是否可以回收
	* 引用计数：给对象添加一个引用计数器，增加一个引用就加一，减少一次就减一，当引用计数为0的时候，该对象可以被回收
	* 可达性：虚拟机栈中引用对象，本地方法栈中的对象，方法区中类静态引用对象和常量对象。以这些对象为起始点进行搜索，能够到达的是可用的，不可到达的是可以被回收的。
2. 垃圾收集算法
	* 标记 - 清除：按照对象是否可以被回收的规则对可以被回收的对象进行标记，GC的时候回收这些标记的对象。标记和清除的过程效率不高，容易产生碎片，不连续内存空间导致无法被使用。
	* 标记 - 整理：按照对象是否可以被回收的规则对可以被回收的对象进行标记，然后把存活但没有被标记的对象往一段移动，清理掉移动过来之外的所有内存，保证剩下内存的连续性。
	* 复制：将内存划分成两部分，每次只使用其中的一块。根据对象可达性分析，将存活对象复制到另外一块内存上面，清除掉这一块内存。
	* 分代收集：新生代 -> 复制算法。老年代 -> 标记整理
3. 垃圾回收器的种类
	* 垃圾收集器模型：年轻代中有Serial，ParNew，Parallel Scavenge收集器。老年代中有CMS,Serial old，Parallel old收集器
	年轻代：
	* Serial：单线程收集器，没有线程间交互开销，收集效率很高，收集时暂停所有线程。
	* ParNew：Serial收集器的多线程版本。
	* Parallel Scavenge：是并行的多线程收集器。
	老年代：
	* Serial Old：Serial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。
	* Parallel Old：是 Parallel Scavenge 收集器的老年代版本。
	* CMS：并发收集、低停顿。基于标记-清除算法实现的
4. 垃圾回收时机
	* 手动调用GC进行垃圾回收
	* 创建对象时，对年轻代内存空间进行扫描查看是否需要回收。